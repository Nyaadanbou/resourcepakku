# NekoRP

A resourcepack distributor running on Velocity platform, with emphasis on the prevention of malicious traffic.

#### Brainstorm

目标：
让玩家在不同服务器上使用不同的资源包。

背景：
Minecraft 最新版本已经支持同一个服务器向玩家分发多个资源包。

需要注意的是，对于客户端而言，无论我们代理端后方的服务器有多少个，客户端所感知到的永远只有一个服务器。

在这个语境下，对于一个 Velocity 插件而言，这台服务器就是我们的 Velocity，而不是后端的服务器。

当客户端在代理端内切换服务器，客户端所感知到的也仅仅是切换世界罢了，并不涉及切换服务器。

术语：
正如背景里所提到的，客户端所感知到的服务器和实际代码里所对应的服务器不是一码事。

我们定义，“服务器”一词指的是后端服务器，而 Velocity 或“代理”指的是客户端所感知到的服务器。

方案：
逻辑流程上，当玩家连接到一个服务器后，应该**移除**客户端当前所应用的资源包，然后**应用**当前服务器所配置的所有资源包。

正如在背景里所提到的，现在 Minecraft 支持 *代理* 向客户端发送多个资源包，因此在数据结构设计上，一个服务器下需要对应多个资源包，而不是单一个。

具体如何**移除**和**应用**，我们引入一点简单的集合操作，来避免一些多余的操作。

假设有如下设置：
服务器A：{ }
服务器B：{RP1，RP2，RP3}
服务器C：{RP2，RP3，RP4}

为了方面，把上面看成三个集合。

一开始，客户端没有连接到代理。

当客户端连接到服务器A时，因为服务器A没有资源包，因此代理端不做任何操作。现在，客户端没有任何应用的资源包。

当客户端从服务器A到连接到B时，我们应用服务器B的所有资源包到客户端。现在，客户端应用的资源包有 {RP1，RP2，RP3}。

当客户端从服务器B连接到服务器C时，我们对客户端当前所应用的资源包集合与服务器C的资源包集合取交集，得到 {RP2，RP3}，称其为U1。然后，用服务器C的资源包集合减去U1，得到一个新的集合，称其为D1。

这个集合D1，就是实际要新应用到客户端的资源包列表。

通过以上集合操作，可以避免不必要的资源包移除和应用请求，缩短客户端配置资源包的时间。
